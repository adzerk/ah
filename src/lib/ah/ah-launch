#!/usr/bin/env bash

role_policy_json=$(cat <<EOT
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": "sts:AssumeRole",
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      }
    }
  ]
}
EOT
)

role_policy_inline_json=$(cat <<EOT
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ec2:DescribeTags"
      ],
      "Resource": [
        "*"
      ]
    }
  ]
}
EOT
)

ah_info "Loading AWS configuration info..."

avail_azs=$(aws ec2 describe-availability-zones \
  |jt AvailabilityZones [ ZoneName % ])

avail_vpcs=$(aws ec2 describe-vpcs \
  |jt Vpcs [ VpcId % ] [ Tags [ Key % ] [ Value % ] ] \
  |sort \
  |awk -F' ' '$2 == "Name" {print $1 "\t" $3}')

avail_subnets=$(aws ec2 describe-subnets \
  |jt Subnets [ VpcId % ] [ SubnetId % ] [ AvailabilityZone % ] [ CidrBlock % ] \
  |awk -F'	' '{print $1 "\t" $2 "\t" $3 " " $4}' \
  |sort -k3)

avail_images=$(aws ec2 describe-images --owners $(ah_account_id) \
  |jt Images [ ImageId % ] [ Name % ] \
  |sort -k2)

avail_instance_types=$(cat "${AH_LIB}/instance-types.txt")

avail_keys=$(aws ec2 describe-key-pairs --no-paginate \
  |jt KeyPairs [ KeyName % ])

avail_orgs=$(ah_s3_ls etc |sed 's@\.conf$@@')

ah_success "OK.\n"

asg_info=$(ah_asg_info $AH_ENV)

ah_info "Checking autoscaling group exists..."

AH_ASG_LAUNCH_CONFIG_NAME=$(ah_asg_launch_config_name "$asg_info")

if [[ -n "$AH_ASG_LAUNCH_CONFIG_NAME" ]]; then
  ah_success "[Y]\n"
  update=true

  ah_check "app policy exists" ah_policy_exists || ah_die "aborted."
  ah_check "SG exists" ah_sg_exists $AH_ENV || ah_die "aborted."
  ah_check "role exists" ah_role_exists $AH_ENV || ah_die "aborted."
  ah_check "instance profile exists" ah_instance_profile_exists $AH_ENV || ah_die "aborted."
  ah_check "launch configuration exists" ah_launch_config_exists "$AH_ASG_LAUNCH_CONFIG_NAME" || ah_die "aborted."

  AH_ASG_VPC_SUBNETS=$(ah_asg_vpc_subnets "$asg_info")
  AH_ASG_AZS=$(ah_asg_azs "$asg_info")
  AH_ASG_SAVED=$(set |grep '^AH_ASG_' |sort)

  sg_info=$(ah_sg_info $AH_ENV)

  AH_SG_VPC=$(ah_sg_vpc "$sg_info")

  lc_info=$(ah_launch_config_info $AH_ASG_LAUNCH_CONFIG_NAME)

  AH_LC_NAME=$AH_ASG_LAUNCH_CONFIG_NAME
  AH_LC_IMAGE_ID=$(ah_launch_config_image_id "$lc_info")
  AH_LC_KEY_NAME=$(ah_launch_config_key_name "$lc_info")
  AH_LC_SECURITY_GROUPS=$(ah_sg_id_by_name $AH_ENV)
  AH_LC_INSTANCE_TYPE=$(ah_launch_config_instance_type "$lc_info")
  AH_LC_ASSOCIATE_PUBLIC_IP=$(ah_launch_config_associate_public_ip "$lc_info")
  AH_LC_CLASSIC_LINK_VPC=$(ah_launch_config_classic_link_vpc_id "$lc_info")
  AH_LC_CLASSIC_LINK_SGS=$(ah_launch_config_classic_link_security_groups "$lc_info")
  AH_LC_SAVED=$(set |grep '^AH_LC_' |sort)
else
  ah_success "[N]\n"
  update=false

  ah_check "app policy exists" ah_policy_exists || ah_die "aborted."
  ah_check "SG does not already exist" ah_not ah_sg_exists $(ah_var AH_ENV) || ah_die "aborted."
  ah_check "role does not already exist" ah_not ah_role_exists $AH_ENV || ah_die "aborted."
  ah_check "instance profile does not already exist" ah_not ah_instance_profile_exists $AH_ENV || ah_die "aborted."
  ah_check "launch configuration does not already exist" ah_not ah_launch_config_exists $AH_ENV || ah_die "aborted."
fi

if ! $update; then
  while ah_select -p "Org to use as a template? " template "$avail_orgs"; do
    [[ $template ]] && break
  done
  if [[ -n "$template" ]]; then
    . <(aws s3 cp s3://$(ah_var AH_BUCKET)/etc/${template}.conf - \
        --region $AH_MASTER_REGION \
        |grep . |sed 's@^@export @')
  fi
fi

while true; do
  if ! $update; then
    while ah_select -p "Launch into VPC? " AH_SG_VPC "$avail_vpcs"; do
      [[ $AH_SG_VPC ]] && break
    done
  fi

  if [[ ! $AH_SG_VPC ]]; then
    if ! $update; then
      while ah_select -p "Enable classic link to VPC? " AH_LC_CLASSIC_LINK_VPC "$avail_vpcs"; do
        [[ $AH_LC_CLASSIC_LINK_VPC ]] && break
      done
    fi

    while true; do
      ah_select -mp "Availability zones to launch instances in? " AH_ASG_AZS "$avail_azs" \
        || [[ -z "$AH_ASG_AZS" ]] \
        || break
    done
  else
    sn=$(echo "$avail_subnets" |awk -F'	' -vVPC=$AH_SG_VPC '$1 == VPC {print $2 "\t" $3}')
    [[ ! $sn ]] && ah_warning "VPC contains no subnets" && continue
    while true; do
      ah_select -mp "Subnets for VPC? " AH_ASG_VPC_SUBNETS "$sn" \
        || [[ -z "$AH_ASG_VPC_SUBNETS" ]] \
        || break
    done

    AH_LC_ASSOCIATE_PUBLIC_IP=${AH_LC_ASSOCIATE_PUBLIC_IP:=yes}
    while ah_select -v AH_LC_ASSOCIATE_PUBLIC_IP "yes	assign public IPs to instances"; do
      :
    done
  fi

  if ! $update; then
    ah_text_input -p "Billing group? " AH_BILLING_GROUP
    ah_text_input -p "Billing project? " AH_BILLING_PROJECT
  fi

  while ah_select -p "Machine image? " AH_LC_IMAGE_ID "$avail_images"; do
    [[ "$AH_LC_IMAGE_ID" ]] && break
  done

  while ah_select -p "SSH key pair to use? " AH_LC_KEY_NAME "$avail_keys"; do
    [[ "$AH_LC_KEY_NAME" ]] && break
  done

  while ah_select -p "Instance type? " AH_LC_INSTANCE_TYPE "$avail_instance_types"; do
    [[ "$AH_LC_INSTANCE_TYPE" ]] && break
  done

  vars=$(set |grep -E "^AH_($(if [[ -z "$AH_ASG_VPC_SUBNETS" ]] ; then echo "ASG_AZS|" ; else echo "ASG_VPC_SUBNETS|" ; fi)|BILLING_GROUP|BILLING_PROJECT|ENV|LC_IMAGE_ID|LC_KEY_NAME|LC_INSTANCE_TYPE|SG_VPC|ASG_VPC_SUBNETS|LC_CLASSIC_LINK_VPC)=" |sort)

  echo
  echo "$vars"
  echo

  read -sn 1 -p "$(ah_bold "Approve? [")yN$(ah_bold "] ")" approve
  [[ "$approve" == "y" ]] && echo && break;

  echo
  echo "Okay, starting over (ctrl-c to abort)."
  echo
done

AH_ASG_NEW=$(set |grep '^AH_ASG_' |grep -v '^AH_ASG_SAVED=' |sort)
AH_LC_NEW=$(set |grep '^AH_LC_' |grep -v '^AH_LC_SAVED=' |sort)

[[ $AH_ASG_NEW != $AH_ASG_SAVED ]] && asg_changed=true || asg_changed=false
[[ $AH_LC_NEW  != $AH_LC_SAVED  ]] && lc_changed=true  || lc_changed=false

if ! $lc_changed; then
  read -sn 1 -p "$(ah_bold "Launch config settings unchanged. Update launch config anyway? [")yN$(ah_bold "] ")" approve
  [[ "$approve" == "y" ]] && lc_changed=true
fi

if ! $update; then
  ah_try -m "Creating role..." \
    aws iam create-role \
      --path /ah/ \
      --role-name $AH_ENV \
      --assume-role-policy-document "$role_policy_json" \
      > /dev/null

  ah_try -m "Attaching app policy..." \
    aws iam attach-role-policy \
      --role-name $AH_ENV \
      --policy-arn $(ah_policy_arn ah/$AH_APP) \
      > /dev/null

  ah_try -m "Creating inline policy..." \
    aws iam put-role-policy \
      --role-name $AH_ENV \
      --policy-name ec2-describe-tags \
      --policy-document "$role_policy_inline_json" \
      > /dev/null

  ah_try -m "Creating instance profile..." \
    aws iam create-instance-profile \
      --path /ah/ \
      --instance-profile-name $AH_ENV \
      > /dev/null

  ah_try -m "Adding role to instance profile..." \
    aws iam add-role-to-instance-profile \
      --role-name $AH_ENV \
      --instance-profile-name $AH_ENV \
      > /dev/null

  # creating security groups:
  # -vpc                create vpc sg
  # -classic link       create vpc sg and ec2 classic sg
  # -ec2 classic        create ec2 classic sg

  if [[ $AH_SG_VPC ]]; then
    the_vpc="VPC $AH_SG_VPC"
    more_opts="--vpc-id ${AH_SG_VPC}"
  elif [[ $AH_LC_CLASSIC_LINK_VPC ]]; then
    the_vpc="VPC $AH_LC_CLASSIC_LINK_VPC"
    more_opts="--vpc-id ${AH_LC_CLASSIC_LINK_VPC}"
    # for classic link we create an sg in the vpc and in ec2 classic
    ec2c_sg_id=$(ah_try -m "Creating SG in EC2 classic..." \
      aws ec2 create-security-group \
        --group-name $AH_ENV \
        --description "Ah security group for the $AH_ENV environment, $AH_APP application." \
        | jt GroupId %)
  else
    the_vpc="EC2 classic"
  fi
  sg_id=$(ah_try -m "Creating SG in ${the_vpc}..." \
    aws ec2 create-security-group \
      --group-name $AH_ENV \
      --description "Ah security group for the $AH_ENV environment, $AH_APP application." \
      $more_opts \
    |jt GroupId %)
  [[ ! $sg_id ]] && ah_die "could not create security group"
  echo done.
fi

if ! $update || $lc_changed; then
  AH_LC_NAME_NEW="${AH_ENV}-$(date +'%Y-%m-%d-%H%M%S-%s')"
  if [[ $AH_SG_VPC ]]; then
    if [[ $AH_LC_ASSOCIATE_PUBLIC_IP == yes ]]; then
      more_lc_opts="--associate-public-ip-address"
    else
      more_lc_opts="--no-associate-public-ip-address"
    fi
  fi
  if [[ $AH_LC_CLASSIC_LINK_VPC ]]; then
    more_lc_opts="$more_lc_opts --classic-link-vpc-id $AH_LC_CLASSIC_LINK_VPC --classic-link-vpc-security-groups $sg_id"
  fi

  # If we're classic linking, there are 2 SGs, and we only want to use the one
  # in EC2 Classic when creating the launch configuration.
  #
  # (The ID of the other SG, the VPC one, is supplied as part of $more_lc_opts.)
  if [[ -n "$ec2c_sg_id" ]]; then
    lc_sg_ids="$ec2c_sg_id"
  else
    lc_sg_ids=$(ah_sg_id_by_name $AH_ENV)
  fi

  ah_retry -m "Creating launch configuration..." \
    aws autoscaling create-launch-configuration \
      --launch-configuration-name $AH_LC_NAME_NEW \
      --image-id $AH_LC_IMAGE_ID \
      --key-name $AH_LC_KEY_NAME \
      --security-groups "$lc_sg_ids" \
      --user-data "$(cat $AH_SHR/user-data.sh |envsubst '$AH_APP:$AH_ENV:$AH_BUCKET:$AH_MASTER_REGION')" \
      --instance-type $AH_LC_INSTANCE_TYPE \
      --iam-instance-profile $(ah_instance_profile_arn ah/$AH_ENV) \
      $more_lc_opts \
      > /dev/null
fi

if [[ $AH_ASG_VPC_SUBNETS ]]; then
  more_opts="--vpc-zone-identifier $(echo "${AH_ASG_VPC_SUBNETS}" |sed 's@  *@,@')"
else
  more_opts="--availability-zones ${AH_ASG_AZS}"
fi

if ! $update; then
  ah_try -m "Creating autoscaling group..." \
    aws autoscaling create-auto-scaling-group \
      --auto-scaling-group-name $AH_ENV \
      --launch-configuration-name $AH_LC_NAME_NEW \
      --min-size 0 \
      --max-size 0 \
      --desired-capacity 0 \
      --tags "ResourceId=$AH_ENV,ResourceType=auto-scaling-group,Key=AhApplication,Value=$AH_APP" \
            "ResourceId=$AH_ENV,ResourceType=auto-scaling-group,Key=AhEnvironment,Value=$AH_ENV" \
            "ResourceId=$AH_ENV,ResourceType=auto-scaling-group,Key=Name,Value=$AH_ENV" \
            "ResourceId=$AH_ENV,ResourceType=auto-scaling-group,Key=BillingGroup,Value=$AH_BILLING_GROUP" \
            "ResourceId=$AH_ENV,ResourceType=auto-scaling-group,Key=BillingProject,Value=$AH_BILLING_PROJECT" \
      $more_opts \
      > /dev/null

  ah_try -m "Enabling metrics on autoscaling group..." \
    aws autoscaling enable-metrics-collection \
      --auto-scaling-group-name $AH_ENV \
      --granularity 1Minute \
      > /dev/null
elif $asg_changed && $lc_changed; then
  ah_try -m "Updating autoscaling group..." \
    aws autoscaling update-auto-scaling-group \
      --auto-scaling-group-name $AH_ENV \
      --launch-configuration-name $AH_LC_NAME_NEW \
      $more_opts \
      > /dev/null
elif $asg_changed && ! $lc_changed; then
  ah_try -m "Updating autoscaling group..." \
    aws autoscaling update-auto-scaling-group \
      --auto-scaling-group-name $AH_ENV \
      --launch-configuration-name $AH_LC_NAME \
      $more_opts \
      > /dev/null
elif ! $asg_changed && $lc_changed; then
  ah_try -m "Updating autoscaling group..." \
    aws autoscaling update-auto-scaling-group \
      --auto-scaling-group-name $AH_ENV \
      --launch-configuration-name $AH_LC_NAME_NEW \
      > /dev/null
fi

if $lc_changed && [ -n "$AH_LC_NAME" ]; then
  ah_try -m "Deleting old launch config ($AH_LC_NAME)..." \
    aws autoscaling delete-launch-configuration \
      --launch-configuration-name $AH_LC_NAME \
      > /dev/null
fi
